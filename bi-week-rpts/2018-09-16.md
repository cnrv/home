---
layout: default
---

# RISC-V 双周简报 (2018-09-16)

要点新闻：

## RV新闻

### RISC-V Day Tokyo和RISC-V Summit的议程出炉

TBD

### MIT 和 UC Berkeley 联合启动 Keystone 计划

Keystone: Open-source Secure Hardware Enclave 是 MIT 和 UC Berkeley 在最近联合启动的一个开源计划，
准备建立一个支持硬件隔离运行空间(hardware enclave)的可信执行环境(Trusted Execution Environment, TEE).
已经隔离的运行空间非常重要，基于它的安全计算将能保护私有数据在共有平台上的安全运行，阻止第三方程序甚至操作系统对安全计算的窥探(confidentiality)和篡改(integrity)。
当前已经有较成熟的商业实现，比如Intel的SGX和ARM的TrustZone，学术界也有了[Sanctum](https://eprint.iacr.org/2015/564.pdf)，但是我们还没有完全开放的全栈(full-stack)实现。
Keystone将实现一个开源的实现，和社区一起研究问题和改进设计。

Keystone的目标：
1. 可信链 (Chain of Trust)
    - 可信启动 (Secure boot)
    - 远程认证 (Remote attestation)
    - 安全密钥供给 (Secure key provisioning)
2. 内存隔离 (Memory Isolation)
    - 内存的物理保护 (Physical memory protection)
    - 页表隔离 (Page table isolation)
3. 抵御物理攻击 (Defense against Physical Attack)
    - 内存加密 (Memory encryption)
    - 内存地址总线加密 (Memory address bus encryption)
4. 抵御测信道攻击 (Defense against Side-channel Attack)
    - 基于隔离的体系结构 (Isolated architecture)
5. 形式化验证 (Formal Verification)
6. 部署 (Deployment)
    - RISC-V QEMU 仿真
    - 基于FireSim的FPGA仿真 (FPGA-based deployment (FireSim))
    - 流片 (Tape out to chip)
7. 安全供应链的管理 (Secure supply-chain management)

- Keystone: https://keystone-enclave.org

## 技术讨论

### RISC-V还缺少large code model

`soberl`在`sw-dev` 邮件列表表示在基于Sv48编译的时候碰到了Linking问题（用的是release 20180629 @ https://www.sifive.com/products/tools/ ）源码如下
```C
// b.c: 
int x[0x40000000];           // 4GB
int y;

// main.c:
extern int x[0x40000000];
extern int y;
__attribute__((noinline)) void fooA(long a, long b) {
    asm volatile(""::"r"(a), "r"(b));  // to notify gcc that a/b are depended
}

int main() {
    fooA((long)x, y);             // to try both address access and load on an address
    return 0;
}
```
用编译命令`riscv64-unknown-elf-gcc main.c b.c -mcmodel=medany -save-temps -Os`会得到如下错误信息
```
main.o: In function `main':
main.c:(.text.startup+0x0): relocation truncated to fit: R_RISCV_PCREL_HI20 against symbol `y' defined in COMMON section in b.o
```
对`main.o`反编译后看到`lla a5,y`转成了`auipc`，但是得到的汇编比较奇怪
```asm
   0:   00000797                auipc   a5,0x0
   4:   00078793                mv      a5,a5
```
如果用`-fPIC`或者`-fPIE`选项（地址无关码，见\[1\]和\[2\]），并且加上`-nostdlib`的话Linking可以通过，但是此时编译器给出的是`la a5,y`，并且变成了`auipc`和`ld`
```asm
   100b0:       00001797                auipc   a5,0x1
   100b4:       0587b783                ld      a5,88(a5) # 11108 <_GLOBAL_OFFSET_TABLE_+0x10>
```

对此Andrew认为是预料之中的，如果需要用到超过2GiB的静态数据，必须得用PIC（包括对library代码）。因为PIC会影响到代码大小和性能，在给大量静态数据分配内存的时候，建议最好使用`malloc`或者`mmap`。

`soberl`随后贴出了另外一个例子（上例用了很大的数组其实是为了说明问题方便），实际的Linker Script是这样的，数据的物理地址从4GiB开始，并且Mbare模式下物理地址和虚拟地址相等。
```
MEMORY { 
    code :  ORIGIN = 0x00000000, LENGTH = 0x00010000 
    data :  ORIGIN = 0x100000000, LENGTH = 0x00010000 
} 
```
这样的情况下，上例中的`b.c`哪怕是用“正常”大小的数组
```C
// b.c
int x[0x10]; 
int y;
```
编译使用命令`riscv64-unknown-elf-gcc main.c b.c -mcmodel=medany -save-temps -Os -march=rv64imafd -nostdlib -T test.ld`，还是会有同样的报错
```
main.o: In function `main': 
main.c:(.text.startup+0x0): relocation truncated to fit: R_RISCV_PCREL_HI20 against symbol `y' defined in COMMON section in b.o
```
这样是不是意味着，code和data的地址偏移必须都得放在2GiB的范围之内？

`Andrew Waterman`表示的确如此，并且这个其实部分来自于RISC-V的基本设计理念。因为实现大跨度的相对PC寻址（或者甚至是绝对寻址）都需要比较多的指令，另外这种需求也被认为不是很多，所以目前RISC-V没有做“大”code的模型。支持大code最终还是会做的，目前为了达到目的，可以把code和data相对放的靠近一些。使用PIC并不是最好的替代办法， 因为对静态变量的处理有可能和预期不一致（编译器会生成相对PC寻址，而不是用全局位移表GOT, Global Offset Table）。
> Yes, that's right.  Part of this is fundamental to RISC-V.  It takes a bunch of instructions to implement PC-relative addressing (or even absolute addressing) with larger offsets.  Because of this, and the perceived lack of need, we haven't yet made a "large" code model.
> 
> We should do that eventually, but in the mean time, the best workaround is to put the code and the data closer together somehow.  PIC is not a great workaround, because it won't handle static variables the way you want (the compiler will use PC-relative addressing for these, rather than GOT-indirect addressing).


Links 
- [（讨论原文）Link issue (relocation truncated to fit) with large data offset](https://groups.google.com/a/groups.riscv.org/forum/#!msg/sw-dev/VyvVDnMwKmA/RCZJebdICQAJ)
- [\[1\] GCC 手册：关于-fPIC](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-fPIC)
- [\[2\] GCC 手册：关于-fPIE](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-fPIE)

### Chisel 合并 Vec 对象的方法

Edmond Cote 在邮件列表里问到，除了像下面的例子用 for 循环的方式逐个赋值之外，是否有更好的方式？
```scala
val storeTableWalkerRequest: Vec[Bool] = Wire(Vec(NumStorePorts, Bool()))

val loadTableWalkerRequest: Vec[Bool] = Wire(Vec(NumLoadPorts, Bool()))

// Concatenate all request vectors

val tableWalkerRequests: Vec[Bool] = Wire(Vec(NumStorePorts + NumLoadPorts, Bool()))

for (i <- 0 until NumStorePorts) {
  tableWalkerRequests(i) := storeTableWalkerRequest(i)
}

for (i <- NumStorePorts until NumStorePorts + NumLoadPorts) {
  tableWalkerRequests(i) := loadTableWalkerRequest(i - NumStorePorts)
}

```

Steve Burns 给出了解决方法：

```scala
VecInit(IndexedSeq((storeTableWalkerRequest ++ loadTableWalkerRequest):_*) )
```

小编对此的理解是， `storeTableWalkerRequest` 和 `loadTableWalkerRequest` 是 Chisel 的 `Vec` 类型，它继承自 Scala 的 `IndexedSeq` 类型，可以用 `++` 符号把两个 `Vec` 合并，然后为了把合并后的 `Vec` 变成 `IndexedSeq` 类型，需要用 `IndexedSeq()` 进行转换。`IndexedSeq()` 接受多个参数而不是一个集合，所以需要用 `:_*` 把一个集合参数变成多个参数，最后在用 `VecInit()` 变成 `Vec` 类型。

不过小编疑惑的是，既然 Chisel 的 `Vec` 类型继承自 Scala 的 `IndexedSeq` 类型，可以用 `++`  符号合并，这样应该就算是合并两个 `Vec` 了，何必像上面那么麻烦呢？

## 代码更新

### Chisel实验性的支持将文件内容载入Memeory

Chisel最近开始支持从文件载入十六进制或者二进制的内容到Memeory中用于**仿真**。这一功能和verilog的`$readmem`实现类似的功能。

此功能将一定程度的方便开发者，以下是简单的示例。

```scala
import chisel3.util.experimental.loadMemoryFromFile

val memory = Mem(memoryDepth, memoryType)

loadMemoryFromFile(memory, "/workspace/workdir/mem1.txt")
```

Links: 
  - [Chisel Memories](https://github.com/freechipsproject/chisel3/wiki/Chisel-Memories)
  - [Github PR: freechipsproject/chisel3/pull/840](https://github.com/freechipsproject/chisel3/pull/840)

## 安全点评

## 微群热点

## 实用资料

## 行业视角

## 市场相关


## CNRV社区活动

## CNRV网站更新

## 会议征稿


## 暴走事件

### 2018年10月

- 2018年10月18日, RISC-V Day Tokyo将在Keio University举办，演讲征集已经开始。[注册网站](https://tmt.knect365.com/risc-v-day-tokyo/)

### 2018年12月

- 2018年11月13-14日 [Chisel Community Conference](https://chisel.eecs.berkeley.edu/blog/?p=200)将会在湾区举办，会议开放Call for Paper，地点还没有完全确定
- 2018年12月3-5日 [RISC-V Summit in Santa Clara (Dec. 3-5)](http://cts.businesswire.com/ct/CT?id=smartlink&url=https%3A%2F%2Ftmt.knect365.com%2Frisc-v-summit%2F&esheet=51792917&newsitemid=20180423005251&lan=en-US&anchor=RISC-V+Summit+in+Santa+Clara&index=4&md5=88ca965085b5b1b9b6ea996333f27e44)

## 招聘简讯

_CNRV提供为行业公司提供公益性质的一句话的招聘信息发布，若有任何体系结构、IC设计、软件开发的招聘信息，欢迎联系我们！_

----

整理编集: 宋威、黄柏玮、汪平、林容威、傅炜、巍巍、郭雄飞、黄玮、李健

----

**欢迎关注微信公众号CNRV，接收最新最时尚的RISC-V讯日, RISC-V Day Tokyo将在Keio University举办，演讲征集已经开始。[注册网站](https://tmt.knect365.com/risc-v-day-tokyo/)
息！**

![CNRV微信公众号](/assets/images/cnrv_qr.png)

----

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/cn/80x15.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/">知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议</a>进行许可。

